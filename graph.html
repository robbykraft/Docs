<!-- START OF HEADER -->
<!-- START OF HEADER -->
<!-- START OF HEADER -->
<!DOCTYPE html>
<html>
<head>
<title>Rabbit Ear</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="text/javascript" src="../Origami/rabbit-ear.js"></script>
<script type="text/javascript" src="../SVG/svg.js"></script>
<script type="text/javascript" src="../fold-to-svg/fold-to-svg.js"></script>
<script>
SVG.use(FoldToSvg);
FoldToSvg.use(SVG);
ear.use(SVG);
ear.use(FoldToSvg);
</script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Cormorant:300,500,700">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700">
<link rel="stylesheet" href="./css/reset.css" />
<link rel="stylesheet" href="./css/style.css" />
<link rel="stylesheet" href="./css/code.css" />
<link rel="stylesheet" href="./css/nav.css" />
<link rel="stylesheet" href="./css/input-range.css" />
<link rel="stylesheet" href="./css/button.css" />
</head>
<body>
  <nav>
    <div class="mobile-nav-dropdown">
      <div class="mobile-nav-button"><img src="images/menu.svg"></div>
      <div class="nav-wrapper">
        <ul>
          <li class="dropdown">
            <a href="/docs/">HELLO</a>
          </li>
          <li class="dropdown">
            <a href="/docs/math.html" class="dropbtn">I. MATH</a>
          </li>
          <li class="dropdown">
            <a href="/docs/graph.html" class="dropbtn">II. GRAPHS</a>
          </li>
          <li class="dropdown">
            <a href="/docs/svg.html" class="dropbtn">III: SVG</a>
          </li>
          <li class="dropdown">
            <a href="/docs/origami.html" class="dropbtn">IV. ORIGAMI</a>
          </li>
          <li class="dropdown">
            <a href="/docs/appendix.html" class="dropbtn">APPENDIX</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <div class="main-content">
<!-- END OF HEADER -->
<!-- END OF HEADER -->
<!-- END OF HEADER -->

<h3>
  CHAPTER II.
</h3>

<h1>
  GRAPHS
</h1>

  <div class="d3-force-graph">
    <svg id="svgTest00"></svg>
  </div>

<p class="quote">
  A <b>graph</b> is a collection of <b>vertices</b>, <b>edges</b>, and <b>faces</b>.
</p>

  <pre class="code"><code><f>var</f> graph <key>=</key> ear.<f>graph</f>()</code></pre>

<p>
  Graphs don't need to exist in 2D space (or any space), they are an abstract map showing connections between vertices.
</p>

<h3>Adjacency</h3>

<div class="grid-2">
  <div>
    <div class="d3-force-graph">
      <svg id="svgTest01"></svg>
    </div>
    <p class="quote">
      adjacent vertices
    </p>
    <pre class="code"><code><span id="spanNodesAdjacentToNodeResult"></span>graph.vertices[<n><span id="spanNodesAdjacentToNodeInput" class="token argument"></span></n>].<f>vertices</f><br><span id="spanNodesAdjacentToEdgeResult"></span>graph.edges[<n><span id="spanNodesAdjacentToEdgeInput" class="token argument"></span></n>].<f>vertices</f></code></pre>
  </div>
  <div>
    <div class="d3-force-graph">
      <svg id="svgTest02"></svg>
    </div>
    <p class="quote">
      adjacent edges
    </p>
    <pre class="code"><code><span id="spanEdgesAdjacentToNodeResult"></span>graph.vertices[<n><span id="spanEdgesAdjacentToNodeInput" class="token argument"></span></n>].<f>edges</f><br><span id="spanEdgesAdjacentToEdgeResult"></span>graph.edges[<n><span id="spanEdgesAdjacentToEdgeInput" class="token argument"></span></n>].<f>edges</f></code></pre>
  </div>
</div>

<!-- <p class="quote">
  Adjacencies can be used to calculate faces.
</p>
 -->

<h3>
  Components
</h3>

  <pre class="code"><code>graph.<f>vertices</f><br>graph.<f>edges</f><br>graph.<f>faces</f></code></pre>

<p class="quote">
  Components are referred to by their <b>indices</b>.
</p>

<p>
  Component queries will return an integer; this is the component's index in its arrays.
</p>

  <div id="canvas-graph-nearest-components"></div>

  <pre class="code"><code>ear.graph.<f>nearest_vertex</f>(<arg>graph</arg>)<br>ear.graph.<f>nearest_edge</f>(<arg>graph</arg>)<br>ear.graph.<f>nearest_face</f>(<arg>graph</arg>)</code></pre>

<h2>
  FOLD
</h2>

<p>
  In 2016, a file format was developed specifically for origami: <a href="https://github.com/edemaine/fold#readme">the FOLD format</a>. The benefit of this being a Javascript library is that it integrates seamlessly with a JSON-based format.
</p>

<pre class="code compact"><code><f>FOLD graph</f>
┃
┃ <c>// vertices</c>
┣━ vertices_coords
┣━ <v>vertices_vertices</v>
┣━ <v>vertices_edges</v>
┣━ <v>vertices_faces</v>
┃
┃ <c>// edges</c>
┣━ <v>edges_vertices</v>
┣━ <v>edges_faces</v>
┃
┃ <c>// faces</c>
┣━ <v>faces_vertices</v>
┗━ <v>faces_edges</v>
┗━ <v>faces_faces</v>
</code></pre>

<p>
  FOLD is JSON-based, it's not impossible to peek inside and modify the contents manually.
</p>

  <div>
    <svg viewBox="-0.05 -0.05 1.1 1.1" stroke-width="0.02" fill="none">
      <path stroke="black" stroke-dasharray="0.0001 0.05 0.0333 0.05" stroke-linecap="round" d="M0,0L1,1" />
      <path stroke="black" d="M0,0L1,0L1,1L0,1Z" />
    </svg>
  </div>

  <pre class="code"><code>{<br>  vertices_coords: [[<n>0</n>, <n>0</n>], [<n>1</n>, <n>0</n>], [<n>1</n>, <n>1</n>], [<n>0</n>, <n>1</n>]],<br>  edges_vertices: [[<n>0</n>, <n>1</n>], [<n>1</n>, <n>2</n>], [<n>2</n>, <n>3</n>], [<n>3</n>, <n>0</n>], [<n>0</n>, <n>2</n>]],<br>  edges_assignment: [<str>"B"</str>, <str>"B"</str>, <str>"B"</str>, <str>"B"</str>, <str>"M"</str>]<br>}</code></pre>

<p>
  This library makes it so you don't have to learn the FOLD format. We have methods to add vertices, edges, and faces.
</p>

<h2>
  Creating Graphs
</h2>

<p>
  Our graph is simply a Javascript object.
</p>

  <pre class="code"><code><f>var</f> myGraph <key>=</key> {}</code></pre>

<p>
  Every method that operates on graphs is found under this key:
</p>

  <pre class="code"><code>ear.<f>graph</f></code></pre>

<p>
  Every graph method takes a similar form where the first parameter is the graph; if there are more parameters they come after.
</p>

  <pre class="code"><code>ear.graph.<f>populate</f>(<arg>graph</arg>)<br>ear.graph.<f>translate</f>(<arg>graph</arg>, <arg>x</arg>, <arg>y</arg>)</code></pre>

<p>
  There is also an object-oriented approach. The top-level graph key is also a constructor:
</p>

  <pre class="code"><code><f>var</f> myGraph <key>=</key> ear.<f>graph</f>()</code></pre>

<p>
  If you prefer the object-oriented approach, all the methods exist on your object, allowing you to leave out the first parameter.
</p>

<div class="grid-2">
  <div>
    <pre class="code"><code><f>var</f> myGraph <key>=</key> {}<br>ear.graph.<f>populate</f>(myGraph)<br>ear.graph.<f>translate</f>(myGraph, <n>2</n>, <n>1</n>)</code></pre>
  </div>
  <div>
    <pre class="code"><code><f>var</f> myGraph <key>=</key> ear.<f>graph</f>()<br>myGraph.<f>populate</f>()<br>myGraph.<f>translate</f>(<n>2</n>, <n>1</n>)</code></pre>
  </div>
</div>

<h3>
  Static Initializers
</h3>

<p>
  When modeling origami you tend to start with a boundary. All of the regular polygons have named static initializers.
</p>

  <pre class="code"><code><f>var</f> myGraph <key>=</key> ear.graph.<f>square</f>()</code></pre>

<h2>
  Adding Components
</h2>

<h3>
  Vertices
</h3>

<p>
  <b>add_vertices</b> makes sure that no two vertices exist in the same space, within an adjustable <b>epsilon</b>.
</p>

  <div id="canvas-graph-add-vertices"></div>

  <pre class="code"><code>ear.graph.<f>add_vertices</f>(<arg>graph</arg>, [[<n>x</n>, <n>y</n>], [<n>x</n>, <n>y</n>], <key>...</key>])</code></pre>

<p class="explain">
  If you import a FOLD file with already existing vertices, you can call <b>remove_duplicate_vertices</b> at any time to clean up vertices.
</p>

<h3>
  Edges
</h3>

<p>
  <b>split_edge</b> adds one new vertex and carefully rebuilds the graph around it, adding new edges and updating any adjacent faces.
</p>

  <div id="canvas-graph-split-edge"></div>

  <pre class="code"><code>ear.graph.<f>split_edge</f>(<arg>graph</arg>, <arg>edge</arg>, <arg>coords</arg>)</code></pre>

<p>
  Give an <b>edge index</b> and <b>coordinates for a new vertex</b>. If no coordinates are given, it will be split at the midpoint.
</p>

<h3>
  Faces
</h3>

<p>
  Splitting a face is more complex; the number of all three component is altered.
</p>

  <div id="canvas-graph-split-face"></div>

  <pre class="code"><code>ear.graph.<f>split_face</f>(<arg>graph</arg>, <arg>face</arg>, <arg>vector</arg>, <arg>origin</arg>)</code></pre>

<p>
  Give a <b>face index</b> and a line by specifying the line's <b>vector</b> and <b>origin</b>.
</p>

<h2>
  Populating arrays
</h2>

<p>
  Without modifying the geometry of a graph we can construct more arrays that express relationships between components.
</p>

<pre class="code"><code>ear.graph.<f>populate</f>(<arg>graph</arg>)</code></pre>

  <svg viewBox="-0.05 -0.05 1.1 1.1" stroke-width="0.02" fill="none">
    <path stroke="black" stroke-dasharray="0.0001 0.05 0.0333 0.05" stroke-linecap="round" d="M0,0L1,1" />
    <path stroke="black" d="M0,0L1,0L1,1L0,1Z" />
  </svg>

<p>
  The populate method will fill out the graph to the best of its ability.
</p>

<pre class="code"><code>vertices_coords: [[<n>0</n>,<n>0</n>], [<n>1</n>,<n>0</n>], [<n>1</n>,<n>1</n>], [<n>0</n>,<n>1</n>]]
edges_vertices: [[<n>0</n>,<n>1</n>], [<n>1</n>,<n>2</n>], [<n>2</n>,<n>3</n>], [<n>3</n>,<n>0</n>], [<n>0</n>,<n>2</n>]]
edges_assignment: [<str>"B"</str>, <str>"B"</str>, <str>"B"</str>, <str>"B"</str>, <str>"M"</str>]</code></pre>

<p>
  becomes
</p>

<pre class="code"><code>vertices_coords: [[<n>0</n>,<n>0</n>], [<n>1</n>,<n>0</n>], [<n>1</n>,<n>1</n>], [<n>0</n>,<n>1</n>]]
vertices_vertices: [[<n>1</n>,<n>2</n>,<n>3</n>], [<n>2</n>,<n>0</n>], [<n>0</n>,<n>1</n>,<n>3</n>], [<n>0</n>,<n>2</n>]]
vertices_edges: [[<n>0</n>,<n>3</n>,<n>4</n>], [<n>0</n>,<n>1</n>], [<n>1</n>,<n>2</n>,<n>4</n>], [<n>2</n>,<n>3</n>]]
vertices_faces: [[<n>0</n>,<n>1</n>], [<n>0</n>], [<n>0</n>,<n>1</n>], [<n>1</n>]]
edges_vertices: [[<n>0</n>,<n>1</n>], [<n>1</n>,<n>2</n>], [<n>2</n>,<n>3</n>], [<n>3</n>,<n>0</n>], [<n>0</n>,<n>2</n>]]
edges_edges: [[<n>3</n>,<n>4</n>,<n>1</n>], [<n>0</n>,<n>2</n>,<n>4</n>], [<n>1</n>,<n>4</n>,<n>3</n>], [<n>2</n>,<n>0</n>,<n>4</n>], [<n>0</n>,<n>3</n>,<n>1</n>,<n>2</n>]]
edges_faces: [[<n>0</n>], [<n>0</n>], [<n>1</n>], [<n>1</n>], [<n>0</n>,<n>1</n>]]
edges_foldAngle: [<n>0</n>, <n>0</n>, <n>0</n>, <n>0</n>, -<n>180</n>]
edges_assignment: [<str>"B"</str>, <str>"B"</str>, <str>"B"</str>, <str>"B"</str>, <str>"M"</str>]
faces_vertices: [[<n>2</n>,<n>0</n>,<n>1</n>], [<n>3</n>,<n>0</n>,<n>2</n>]]
faces_edges: [[<n>4</n>,<n>0</n>,<n>1</n>], [<n>3</n>,<n>4</n>,<n>2</n>]]
faces_faces: [[<n>1</n>], [<n>0</n>]]
</code></pre>

<p>
  but the pattern itself doesn't change.
</p>

<h3>
  Individual Methods
</h3>

<p>
  Populate calls a bunch of methods, each of which is also available for you to call individually. Prerequisites for each method vary.
</p>

<pre class="code"><code><f>var</f> array <key>=</key> ear.graph.<f>make_vertices_vertices</f>(<arg>graph</arg>)</code></pre>

<p>
  These methods <b>do not modify</b> the input graph, they construct and return a new array, it's up to you to assign it to the graph if you wish.
</p>

<pre class="code"><code>ear.graph.<f>make_vertices_edges</f>()
ear.graph.<f>make_vertices_vertices</f>()
ear.graph.<f>make_vertices_faces</f>()
ear.graph.<f>make_vertices_to_edge_bidirectional</f>()
ear.graph.<f>make_vertices_to_edge</f>()
ear.graph.<f>make_vertices_vertices_vector</f>()
ear.graph.<f>make_vertices_sectors</f>()
ear.graph.<f>make_vertices_coords_folded</f>()
</code></pre>

<pre class="code"><code>ear.graph.<f>make_edges_vertices</f>()
ear.graph.<f>make_edges_edges</f>()
ear.graph.<f>make_edges_faces</f>()
ear.graph.<f>make_edges_foldAngle</f>()
ear.graph.<f>make_edges_assignment</f>()
ear.graph.<f>make_edges_vector</f>()
ear.graph.<f>make_edges_length</f>()
ear.graph.<f>get_edges_edges_intersections</f>()
ear.graph.<f>make_edges_collinear_vertices</f>()
</code></pre>

<pre class="code"><code>ear.graph.<f>make_planar_faces</f>()
ear.graph.<f>make_faces_vertices</f>()
ear.graph.<f>make_faces_edges</f>()
ear.graph.<f>make_faces_faces</f>()
ear.graph.<f>make_face_spanning_tree</f>()
ear.graph.<f>make_faces_matrix</f>()
ear.graph.<f>make_faces_center</f>()
ear.graph.<f>make_faces_coloring_from_matrix</f>()
ear.graph.<f>make_faces_coloring</f>()
</code></pre>

<h2>
  More Methods
</h2>

<h3>
  Minimum Spanning Tree
</h3>

  <div id="canvas-graph-faces-tree"></div>

  <pre class="code"><code>ear.graph.<f>make_face_spanning_tree</f>(<arg>graph</arg>, <n>5</n>)</code></pre>

<p>
  A minimum face spanning tree finds edge-adjacent faces; any face can be the starting face.
</p>

<h3>
  Boundary
</h3>

<p>
  Polygons are defined as a <b>sorted</b> array of vertices/edges; required for calculations like intersections.
</p>

<p>
  Because edges are stored in no particular order, finding the boundary requires a sort. This method walks boundary edges until a cycle is found.
</p>

  <div id="canvas-graph-get-boundary"></div>

  <pre class="code"><code>ear.graph.<f>get_boundary</f>(<arg>graph</arg>)</code></pre>

<p>
  Both edges and vertices are included, sorted clockwise / counter-clockwise.
</p>

<p class="explain">
  todo: support for multiple boundaries; a method that tests connected vertices.
</p>

<h3>
  Transformations
</h3>

  <pre class="code"><code>ear.graph.<f>translate</f>(<arg>graph</arg>, <arg>x</arg>, <arg>y</arg>, <arg>z</arg>)
ear.graph.<f>scale</f>(<arg>graph</arg>, <arg>scale</arg>, <arg>origin</arg>)
ear.graph.<f>rotateZ</f>(<arg>graph</arg>, <arg>radians</arg>)
ear.graph.<f>transform</f>(<arg>graph</arg>, <arg>matrix</arg>)</code></pre>

<p>
  We can transform graphs with matrices to rotate, scale, translate the entire graph. But things get more interesting if we apply transformation matrices to <b>subsets</b> of the graph.
</p>

  <div id="canvas-graph-faces-reflect"></div>

  <pre class="code"><code>ear.graph.<f>make_faces_matrix</f>(<arg>graph</arg>)<br>ear.graph.<f>make_vertices_coords_folded</f>(<arg>graph</arg>)</code></pre>

<h3>
  Explode Faces
</h3>

  <div id="canvas-graph-explode-faces"></div>

  <pre class="code"><code>ear.graph.<f>explode_faces</f>(<arg>graph</arg>)</code></pre>

<p>
  Because neighboring faces share vertices, separating faces requires cloning vertices, one unique occurence for every face.
</p>

<h2>
  Counting Components
</h2>

<p>
  Because the geometry is stored in flat, separate arrays, it's possible that the faces are defined in <b>faces_edges</b> but not <b>faces_vertices</b>; and querying the number of faces by checking <b>faces_vertices</b> will break. <b>Count</b> will search all the keys that begin with "faces_" and return the longest one.
</p>

  <pre class="code"><code>ear.graph.count.<f>faces</f>(<arg>graph</arg>)<br>ear.graph.count.<f>edges</f>(<arg>graph</arg>)<br>ear.graph.count.<f>vertices</f>(<arg>graph</arg>)</code></pre>

<p>
  The <b>implied count</b> is useful for things like abstract graphs, a search for vertices will look inside things like "faces_vertices" for the largest index.
</p>

  <pre class="code"><code>ear.graph.implied.<f>faces</f>(<arg>graph</arg>)<br>ear.graph.implied.<f>edges</f>(<arg>graph</arg>)<br>ear.graph.implied.<f>vertices</f>(<arg>graph</arg>)</code></pre>

<p class="explain">
  It's possible that arrays get out of sync, in which case, the longest might not be the correct one. It's very important to watch carefully and never let a component's arrays become unsynchronized.
</p>

<h2>
  Rebuilding Graphs
</h2>

<p>
  This library supports importing a crease pattern from any vector-based drawing program; but some clean-up is necessary.
</p>

<h3>
  Clean
</h3>

  <pre class="code"><code>ear.graph.<f>clean</f>(<arg>graph</arg>)</code></pre>

<p>
  Clean is a fast method that fixes simple issues with validity, it removes:
</p>

<ul>
  <li><b>circular edges:</b> an edge's two vertices are actually the same vertex</li>
  <li><b>duplicate edges:</b> two or more edges are connecting the same two vertices</li>
</ul>

<p>
  The method supports cleaning vertices too; the second parameter is options.
</p>

  <pre class="code"><code>ear.graph.<f>clean</f>(<arg>graph</arg>, {
  edges: <n>true</n>,
  vertices: <n>true</n>
})</code></pre>

<p class="explain">
  Clean is meant to modify the graph as little as possible; more information on remove operations after the next section.
</p>

<h3>
  Planar Graphs
</h3>

  <div id="canvas-graph-fragment"></div>

<p class="quote">
  In planar graphs, it's a violation for two edges to cross.
</p>

<p>
  These are the typical planar graph violations that need addressing when importing from other software:
</p>

<ul>
  <li>lines cross over other lines.</li>
  <li>lines don't always end at <em>exactly</em> the same point.</li>
</ul>

<h3>
  Fragment
</h3>

<p>
  The fragment method converts a graph into a planar graph by solving the first issue: <b>lines crossing other lines</b>.
</p>

<div class="grid-2">
  <div>
    <div id="canvas-graph-fragment-edges"></div>
    <p class="quote" id="fragment-edges-label">edge</p>
    <div style="margin:auto; width: 75%">
      <input type="range" id="fragment-edges-slider" min="0" max="1000" value="0"/>
    </div>
  </div>
  <div>
    <div id="canvas-graph-fragment-faces"></div>
    <p class="quote" id="fragment-faces-label">face</p>
    <div style="margin:auto; width: 75%">
      <input type="range" id="fragment-faces-slider" min="0" max="1000" value="0"/>
    </div>
  </div>
</div>

  <pre class="code"><code><span id="span-merge-result"></span>ear.graph.<f>fragment</f>(<arg>graph</arg>)</code></pre>

<p>
  Fragment substitutes overlapping edges with 4 edges and a new vertex, it splits an edge if another endpoint lies collinear along it, and merges duplicate vertices.
</p>

  <div id="canvas-graph-fragment-epsilon-collinear"></div>

  <p class="quote" id="fragment-epsilon-collinear-label">epsilon</p>

  <div style="margin:auto; width: 50%">
    <input type="range" id="fragment-epsilon-collinear-slider" min="0" max="1000" value="0"/>
  </div>

<p class="quote">
  An edge is split if vertices are collinear within an epsilon.
</p>

<p class="explain">
  The final parameter in many of these methods is an <b>optional epsilon</b>. By default it is very precise (1e-6). When importing crease patterns that were made in some vector drawing program you will want to increase this.
</p>

  <pre class="code"><code>ear.graph.<f>fragment</f>(<arg>graph</arg>, <arg>epsilon</arg> <key>=</key> <n>1e-6</n>)<br>ear.graph.<f>remove_duplicate_vertices</f>(<arg>graph</arg>, <arg>epsilon</arg> <key>=</key> <n>1e-6</n>)</code></pre>

<!-- 
<h3>
  Boundary clipping
</h3>

<p>
  If we are modeling a crease pattern, we want to be able to add lines <b>inside the boundary</b>. Boundaries can clip lines.
</p>

  <pre class="code"><code>ear.graph.<f>clip_line</f>(<arg>graph</arg>, <arg>line</arg>)</code></pre>
 -->

<h3>
  Face-Finding
</h3>

<p>
  The face-finding algorithm walks from edge to edge turning at each corner. This requires vertices be merged, without them corners don't exist.
</p>

  <div id="canvas-graph-merge-vertices"></div>

  <p class="quote" id="graph-merge-vertices-label">epsilon</p>

  <div style="margin:auto; width: 50%">
    <input type="range" id="graph-merge-vertices-slider" min="0" max="1000" value="0"/>
  </div>

<p class="explain">
  This library can build faces in 2D; it's not good with higher dimensions. Notice how faces can be built even if edges are crossing.
</p>

<h3>
  Merge Vertices
</h3>

  <div id="canvas-graph-merge-vertices-animate"></div>

  <pre class="code"><code>ear.graph.<f>remove_duplicate_vertices</f>(<arg>graph</arg>)</code></pre>

<p>
  Removing duplicate vertices will search all the component arrays and make sure the removed vertices are now pointing to the one remaining vertex.
</p>

<p>
  Let's take a closer look at this remove operation.
</p>

<h2>
  Tracking Changes
</h2>

<h3>
  Removing Components
</h3>

<p>
  This library contains methods for removing bad geometry from graphs.
</p>

  <pre class="code"><code>ear.graph.<f>remove_circular_edges</f>(<arg>graph</arg>)
ear.graph.<f>remove_duplicate_edges</f>(<arg>graph</arg>)
ear.graph.<f>remove_isolated_vertices</f>(<arg>graph</arg>)
ear.graph.<f>remove_duplicate_vertices</f>(<arg>graph</arg>, <arg>epsilon</arg>)</code></pre>

<!-- ear.graph.<f>remove_collinear_vertices</f>(<arg>graph</arg>) -->

<p>
  Each of these methods calls the <b>remove</b> method:
</p>

  <pre class="code"><code>ear.graph.<f>remove</f>(<arg>graph</arg>, <arg>key</arg>, <arg>indices</arg>)</code></pre>

<h3>
  Remove
</h3>

<p>
  Consider this, the removal of edges at index 2 and 4.
</p>

  <pre class="code"><code>edges_vertices: {<br>  [[<n>0</n>,<n>1</n>], [<n>2</n>,<n>3</n>], <key>XXXX</key>, [<n>5</n>,<n>2</n>], <key>XXXX</key>, [<n>1</n>,<n>3</n>]]<br>}</code></pre>

<p>
  When a component is removed the following array elements shift up which breaks all references in other arrays. The <b>remove</b> method takes care of this.
</p>

  <pre class="code"><code>ear.graph.<f>remove</f>(graph, <str>"edges"</str>, [<n>2</n>, <n>4</n>])</code></pre>

<!-- <p> -->
<!--   The remove method makes two types of changes to two kinds of arrays: -->
<!-- </p> -->

<!-- <ul> -->
<!--   <li>any arrays with matching prefix (<b>edges_</b>), it will simply remove the index.</li> -->
<!--   <li>any arrays with matching suffix (<b>_edges</b>), go inside each array and update indices to their new reference values due to shifting.</li> -->
<!-- </ul> -->

<p>
  Calling the method modifies the input graph and returns a summary of changes as an array that relates each index to its new location.
</p>

  <pre class="code"><code>[<n>0</n>, <n>1</n>, <n>undefined</n>, <n>2</n>, <n>undefined</n>, <n>3</n>]</code></pre>

<p>
  Notice how the length matches the size of the array <em>before</em> the change. The values in the array answer the question:
</p>

<p class="quote">
  "What is the new location of the old component?"
</p>

<!-- <p> -->
<!-- 	Hence, <em>undefined</em> for components that got removed. -->
<!-- </p> -->

<p>
	I've been calling these arrays <b>maps</b>.
</p>

<h3>
  Maps
</h3>

<p>
	Maps are useful for keeping track of changes <b>from outside the graph</b>. Here's an example:
</p>

<p>
  Imagine a game of dodge ball as a graph, where players are vertices and one of the vertices is a team leader. Players are removed after one round. The last line updates the team leader to its new index.
</p>

  <pre class="code"><code><f>var</f> teamLeader <key>=</key> <n>5</n>;
<f>var</f> changeMap <key>=</key> ear.graph.<f>remove</f>(graph, <str>"vertices"</str>, playersHit);
teamLeader <key>=</key> changeMap[teamLeader];
</code></pre>

<p>
  Updating multiple pointers is also one line of code:
</p>

  <pre class="code"><code>leaders <key>=</key> leaders.<f>map</f>(<arg>i</arg> <f>=&gt;</f> changeMap[i]);</code></pre>

<h3>
	Types of maps
</h3>

<p>
	So far, we've only looked at methods that remove. An example of a method that <em>adds components</em> is the <b>fragment</b> method, in which a single edge can turn into multiple edges. A map to describe this change requires arrays at every index.
</p>

	<pre class="code"><code>[ [<n>0</n>, <n>1</n>, <n>2</n>], [<n>3</n>, <n>4</n>], [<n>5</n>], [<n>6</n>, <n>7</n>, <n>8</n>, <n>9</n>] ]</code></pre>

<p>
	Remember a map answers the question,
</p>

<p class="quote">
  "What is the new location of the old component?"
</p>

<p>
  and fragment converts one edge to multiple edges. However, it is possible to represent the inverse relationship, posing and answering the question:
</p>

<p class="quote">
  "What is the old location of the new component?"
</p>

<p>
	These arrays have a length that matches the geometry <em>after</em> the change, better at representing changes which add entries. This kind of map with the same example above looks like:
</p>

  <pre class="code"><code>[<n>0</n>, <n>0</n>, <n>0</n>, <n>1</n>, <n>1</n>, <n>2</n>, <n>3</n>, <n>3</n>, <n>3</n>, <n>3</n>]</code></pre>

<p>
	I've been calling this kind of map a <b>backmap</b>; it looks <em>back</em> in the history, it relates the current state to the state before the change. The first kind of map we talked about is a <b>nextmap</b>.
</p>

<ul>
	<li><b>nextmap</b>: what is the new index of this old element? the length matches <em>before</em> the change.</li>
	<li><b>backmap</b>: what is the old index of this new element? the length matches <em>after</em> the change.</li>
</ul>

<p>
	All methods in this library, by default, use <b>nextmap</b>.
</p>

<h3>
	Invert
</h3>

<p>
  The <b>invert</b> method will convert one nextmap to a backmap, or visa versa.
</p>

  <pre class="code"><code>ear.graph.<f>invert_map</f>([<n>0</n>, [<n>1</n>, <n>4</n>], <n>6</n>])<br> <key>-&gt;</key> [<n>0</n>, <n>1</n>, <n>undefined</n>, <n>1</n>, <n>2</n>]</code></pre>


<h3>
  Combining Maps
</h3>

<p>
	What makes maps really powerful is the ability to track changes across <em>multiple operations</em> on a graph.
</p>

<pre class="code"><code>ear.graph.<f>merge_nextmaps</f>(<key>...</key>maps)</code></pre>

<p>
	If you perform multiple operations on a graph and save each map you can <b>merge</b> the maps to make one map reflecting the entire change from start to finish.
</p>

  <pre class="code"><code><c>// start with 7 components</c>
[<n>0</n>, <n>1</n>, <n>2</n>, <n>3</n>, <n>4</n>, <n>5</n>, <n>6</n>]
<c>// merge 2 duplicate edges</c>
[<n>0</n>, <n>1</n>, <n>2</n>, <n>1</n>, <n>3</n>, <n>2</n>, <n>4</n>]
<c>// fragment, adds 4 edges</c>
[<n>0</n>, [<n>1</n>, <n>2</n>], <n>3</n>, [<n>4</n>, <n>5</n>, <n>6</n>], [<n>7</n>, <n>8</n>]]
<c>// merge 2 more edges</c>
[<n>0</n>, <n>1</n>, <n>2</n>, <n>3</n>, <n>0</n>, <n>4</n>, <n>3</n>, <n>5</n>, <n>6</n>]</code></pre>

<p>
  The merged map relates each index before the first change to after the final change.
</p>

  <pre class="code"><code>[<n>0</n>, [<n>1</n>, <n>2</n>], <n>3</n>, [<n>1</n>, <n>2</n>], [<n>0</n>, <n>4</n>, <n>3</n>], <n>3</n>, [<n>5</n>, <n>6</n>]]</code></pre>

<p>
	Parameters should be ordered from <em>earliest to most recent</em>, the first change in time should be first.
</p>

<pre class="code"><code>ear.graph.<f>merge_nextmaps</f>(<arg>first</arg>, <arg>second</arg>, <key>...</key>, <arg>final</arg>)</code></pre>

<!-- <p> -->
<!-- 	Imagine this in practice, a crease is added to a crease pattern, getting fragmented and partially merged with existing edges, and in the end you have all the indices to change the mountain/valley assignment later. -->
<!-- </p> -->

<h3>
	Method responses
</h3>

<p class="quote">
	Given a square graph with 4 vertices and edges, adding two more vertices...
</p>

  <pre class="code"><code>ear.graph.<f>add_vertices</f>(graph, [[<n>0.5</n>, <n>0.5</n>], [<n>1</n>, <n>1</n>]])</code></pre>

<p class="quote">
  ...only adds one unique vertex to the array...
</p>

<svg viewBox="-0.2 -0.2 1.4 1.4" stroke-width="0.02" fill="none">
  <path stroke="black" d="M0,0L1,0L1,1L0,1Z" />
  <g stroke="black" fill="white">
    <circle cx="0" cy="0" r="0.04" />
    <circle cx="0" cy="1" r="0.04" />
    <circle cx="1" cy="1" r="0.04" />
    <circle cx="1" cy="0" r="0.04" />
  </g>
  <g fill="#e53" stroke="none">
    <circle cx="1" cy="1" r="0.03" />
    <circle cx="0.5" cy="0.5" r="0.03" />
  </g>
</svg>

	<pre class="code"><code>vertices_coords: [<br>  [<n>0</n>, <n>0</n>], [<n>1</n>, <n>0</n>], [<arg>1</arg>, <arg>1</arg>], [<n>0</n>, <n>1</n>], [<arg>0.5</arg>, <arg>0.5</arg>]<br>]</code></pre>

<p class="quote">
	The response object is a nextmap describing the new index of <em>your parameters</em> provided in the method call.
</p>

  <pre class="code"><code>[<n>4</n>, <n>2</n>]</code></pre>

<p class="quote">
	Notice the second parameter already existed at index 2.
</p>

<!-- ear.graph.<f>remove_collinear_vertices</f>(<arg>graph</arg>) -->

<p>
	All methods that modify a graph return a response object that summarizes the changes.
</p>

<p>
	These remove methods return an object containing a nextmap and the indices that were removed. The indices in the <b>remove</b> array relate to indices <em>before</em> the change.
</p>

  <pre class="code"><code>ear.graph.<f>remove_circular_edges</f>(<arg>graph</arg>)
ear.graph.<f>remove_duplicate_edges</f>(<arg>graph</arg>)
ear.graph.<f>remove_isolated_vertices</f>(<arg>graph</arg>)
ear.graph.<f>remove_duplicate_vertices</f>(<arg>graph</arg>, <arg>epsilon</arg>)</code></pre>

  <pre class="code"><code>{<br>  map: [<n>0</n>, <n>1</n>, <n>2</n>, <n>3</n>, <n>1</n>, <n>4</n>, <n>3</n>, <n>0</n>, <n>5</n>, <n>6</n>]<br>  remove: [<n>4</n>, <n>6</n>, <n>7</n>]<br>}</code></pre>

<p class="explain">
  todo: remove collinear vertices
</p>

<p>
	These two <b>add</b> methods simply return a nextmap. Adding is generally more simple than removing.
</p>

	<pre class="code"><code>ear.graph.<f>add_vertices</f>(<arg>graph</arg>, <key>...</key>)
ear.graph.<f>add_edges</f>(<arg>graph</arg>, <key>...</key>)</code></pre>

  <pre class="code"><code>[<n>4</n>, <n>2</n>]</code></pre>


<!-- ear.graph.<f>add_vertices_split_edges</f>(<arg>graph</arg>) -->

<p>
	Splitting an edge creates one new vertex, removes one edge, and provides one edge nextmap.
</p>

<pre class="code"><code>ear.graph.<f>split_edge</f>(<arg>graph</arg>, <key>...</key>)</code></pre>

<pre class="code"><code>{
  vertex: <n>5</n>,
  edges: {
    map: [<n>0</n>, <n>1</n>, <n>2</n>, [<n>3</n>, <n>4</n>], <n>5</n>, <n>6</n>],
    remove: <n>3</n>,
  }
}</code></pre>

<p>
	Splitting a face creates two new vertices (or maps to one or two existing), removes one face and contains a nextmap containing two new faces, removes up to two edges, creates one new edge (which splits the face), and provides a nextmap which contains the up to four new edges that were made when splitting edges.
</p>

<pre class="code"><code>ear.graph.<f>split_face</f>(<arg>graph</arg>, <key>...</key>)</code></pre>

<pre class="code"><code>{
  vertices: [<n>8</n>, <n>13</n>],
  faces: {
    map: [<n>0</n>, [<n>2</n>, <n>3</n>], <n>1</n>],
    remove: <n>1</n>,
  },
  edges: {
    map: [<n>0</n>, <n>1</n>, <n>2</n>, [<n>6</n>, <n>7</n>], <n>3</n>, <n>4</n>, [<n>8</n>, <n>9</n>], <n>5</n>],
    new: <n>8</n>,
    remove: [<n>3</n>, <n>6</n>]
  }
}</code></pre>

<p>
	Fragment returns a nextmap for edges.
</p>

<p class="explain">
	todo: include vertices nextmap
</p>

	<pre class="code"><code>ear.graph.<f>fragment</f>(<arg>graph</arg>)</code></pre>
	<pre class="code"><code>{
  edges: {
    map: [[<n>0</n>, <n>1</n>], [<n>2</n>, <n>3</n>, <n>4</n>], [<n>5</n>, <n>6</n>, <n>7</n>], [<n>8</n>, <n>9</n>, <n>10</n>, <n>11</n>]]
  }
}</code></pre>

<!-- <pre class="code"><code>{ -->
<!--   vertices: { -->
<!--     map: [[<n>0</n>], [<n>1</n>], [<n>2</n>], [<n>3</n>], [<n>4</n>], [<n>5</n>], [<n>6</n>], [<n>7</n>]] -->
<!--   }, -->
<!--   edges: { -->
<!--     map: [[<n>0</n>, <n>1</n>], [<n>2</n>, <n>3</n>, <n>4</n>], [<n>5</n>, <n>6</n>, <n>7</n>], [<n>8</n>, <n>9</n>, <n>10</n>, <n>11</n>]] -->
<!--   } -->
<!-- }</code></pre> -->

  <!-- <pre class="code"><code>ear.graph.<f>remove_collinear_vertices</f>(<arg>graph</arg>)</code></pre> -->

<p>
  Combining these operations, creasing multiple faces at once, reflecting vertices_coords, is how we are able to simulate folding.
</p>

<h2>
  Acknowledgements
</h2>

<p>
  Interactive graphs at the top of this page are <a href="https://observablehq.com/@d3/force-directed-graph">force direct graphs</a> from <a href="https://d3js.org/">d3.js</a>.
</p>

<script type="text/javascript" src="lib/d3.min.js"></script>
<script type="text/javascript" src="js/graph.d3.js"></script>
<script type="text/javascript" src="js/d3_graph_simple.js"></script>
<script type="text/javascript" src="js/d3_graph_adjNode.js"></script>
<script type="text/javascript" src="js/d3_graph_adjEdge.js"></script>

<script type="text/javascript">
const ExamplesHeader = {};
const ExamplesFooter = {};
ExamplesHeader["graph-fragment-edges"] = `
slider = document.querySelector("#fragment-edges-slider");
countLabel = document.querySelector("#fragment-edges-label");
`;
ExamplesHeader["graph-fragment-faces"] = `
slider = document.querySelector("#fragment-faces-slider");
countLabel = document.querySelector("#fragment-faces-label");
`;
ExamplesHeader["graph-fragment-epsilon-collinear"] = `
slider = document.querySelector("#fragment-epsilon-collinear-slider");
countLabel = document.querySelector("#fragment-epsilon-collinear-label");
`;
ExamplesHeader["graph-merge-vertices"] = `
slider = document.querySelector("#graph-merge-vertices-slider");
countLabel = document.querySelector("#graph-merge-vertices-label");
`;
</script>

<script>
const Callbacks = {};

const loadAndRun = (id, body) => {
  const headText = ExamplesHeader[id] ? ExamplesHeader[id] : "";
  const head = `ear.svg(document.querySelector("#canvas-${id}"), (svg) => {\n${headText}\nvar callback = Callbacks["${id}"];\n`;
  const foot = ExamplesFooter[id]
    ? `\n${ExamplesFooter[id]}\n});\n`
    : `\n});\n`;
  const script = document.createElement("script");
  script.innerHTML = `${head}${body}${foot}`;
  document.body.appendChild(script);
  const node = document.querySelector(`#canvas-${id}`);
  if (!node) { return; }
  const scriptLink = document.createElement("div");
  scriptLink.className = "script-link";
  scriptLink.onclick = function (e) {
    e.preventDefault();
    window.location.href = `/examples/?example=${id}`;
  }
  // node.parentNode.insertBefore(scriptLink, node.nextSibling);
  node.appendChild(scriptLink);
};

[
  "graph-nearest-components",
  "graph-add-vertices",
  "graph-split-edge",
  "graph-split-face",
  "graph-faces-tree",
  "graph-faces-reflect",
  "graph-get-boundary",
  "graph-explode-faces",
  "graph-merge-vertices",
  "graph-merge-vertices-animate",
  "graph-fragment",
  "graph-fragment-edges",
  "graph-fragment-faces",
  "graph-fragment-epsilon-collinear",
].forEach(function (id) {
  fetch(`../examples/${id}.js`)
    .then(function(body) { return body.text(); })
    .then(function(text) { return loadAndRun(id, text); });
});
</script>


<script>
  // $(".accordion-title").html("MORE");
  function updateNodesAdjacentToNode(input, output){
    var outString = '[<span class="token argument">' + output + '</span>] ← ';
    if(input == undefined) { input = ''; outString = ''; }
    document.getElementById("spanNodesAdjacentToNodeInput").innerHTML = input;
    document.getElementById("spanNodesAdjacentToNodeResult").innerHTML = outString;
  }
  function updateNodesAdjacentToEdge(input, output){
    var outString = '[<span class="token argument">' + output + '</span>] ← ';
    if(input == undefined) { input = ''; outString = ''; }
    document.getElementById("spanNodesAdjacentToEdgeInput").innerHTML = input;
    document.getElementById("spanNodesAdjacentToEdgeResult").innerHTML = outString;
  }
  function updateEdgesAdjacentToNode(input, output){
    var outString = '[<span class="token argument">' + output + '</span>] ← ';
    if(input == undefined) { input = ''; outString = ''; }
    document.getElementById("spanEdgesAdjacentToNodeInput").innerHTML = input;
    document.getElementById("spanEdgesAdjacentToNodeResult").innerHTML = outString;
  }
  function updateEdgesAdjacentToEdge(input, output){
    var outString = '[<span class="token argument">' + output + '</span>] ← ';
    if(input == undefined) { input = ''; outString = ''; }
    document.getElementById("spanEdgesAdjacentToEdgeInput").innerHTML = input;
    document.getElementById("spanEdgesAdjacentToEdgeResult").innerHTML = outString;
  }
  var svg = d3.select("div#container")
    .append("svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 960 400")
    .classed("svg-content", true);
</script>

<!-- START OF FOOTER -->
<!-- START OF FOOTER -->
<!-- START OF FOOTER -->
  </div>
</body>
</html>
<!-- END OF FOOTER -->
<!-- END OF FOOTER -->
<!-- END OF FOOTER -->
