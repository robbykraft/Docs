<!DOCTYPE html>

<!-- START OF HEADER -->
<!-- START OF HEADER -->
<!-- START OF HEADER -->
<html>
<head>
<title>Rabbit Ear</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="text/javascript" src="/rabbit-ear.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Cormorant:300,500" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700" />
<link rel="stylesheet" href="./css/reset.css" />
<link rel="stylesheet" href="./css/style.css" />
<link rel="stylesheet" href="./css/code.css" />
<link rel="stylesheet" href="./css/nav.css" />
<link rel="stylesheet" href="./css/input-range.css" />
<link rel="stylesheet" href="./css/button.css" />
</head>
<body>
  <nav>
    <div class="mobile-nav-dropdown">
      <div class="mobile-nav-button"><img src="images/menu.svg"></div>
      <div class="nav-wrapper">
        <ul>
          <li class="dropdown">
            <a href="/docs/">HELLO</a>
          </li>
          <li class="dropdown">
            <a href="/docs/math.html" class="dropbtn">I. MATH</a>
          </li>
          <li class="dropdown">
            <a href="/docs/graph.html" class="dropbtn">II. GRAPHS</a>
          </li>
          <li class="dropdown">
            <a href="/docs/svg.html" class="dropbtn">III: SVG</a>
          </li>
          <li class="dropdown">
            <a href="/docs/origami.html" class="dropbtn">IV. ORIGAMI</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <div class="main-content">
<!-- END OF HEADER -->
<!-- END OF HEADER -->
<!-- END OF HEADER -->

<h3>
  Chapter I.
</h3>

<h1>
  Math
</h1>

  <div id="canvas-junction-bisect"></div>

<p>
	An origami math library contains a fair bit of geometry and linear algebra, as it turns out a lot of time is spent calculating the intersection of shapes. A lot of these intersections are edge-cases (collinear, parallel) so we should have decent control over the epsilon.
</p>

  <pre class="code"><code>ear.<f>math</f></code></pre>

<p>
  Every method discussed here is found under the "math" key except for about 10 object-oriented style primitives, these are at the top-level; let's begin with a few of these.
</p>

<h2 id="vector">
  Vector / Point
</h2>

  <pre class="code"><code>ear.<f>vector</f></code></pre>

<p>
  Vectors can be any dimension with some methods that treat them like vectors, some like points, and some specifically for 2D and 3D.
</p>

<p class="explain">
  2D and 3D specific methods often end in numbers like cross2 and cross3.
</p>

  <div id="canvas-vector"></div>

  <pre class="code"><code><f>var</f> vec <key>=</key> ear.<f>vector</f>(<span id="vec-sketch-vector"><n>0.5</n>, <n>0.666</n></span>)<br>vec.<f>normalize</f>()<br> ↳ <span id="vec-sketch-vector-normalized"></span></code></pre>

  <div id="canvas-vector-lerp"></div>

  <pre class="code"><code><span style="color:#6096bb">blue1</span> = <span style="color:#e44f2a">red1</span>.lerp(<span style="color:#e44f2a">red2</span>, <span id="lerp-time-1">t</span>)<br><span style="color:#6096bb">blue2</span> = <span style="color:#e44f2a">red2</span>.lerp(<span style="color:#e44f2a">red3</span>, <span id="lerp-time-2">t</span>)<br><span style="color:#ecb233">yellow</span> = <span style="color:#6096bb">blue1</span>.lerp(<span style="color:#6096bb">blue2</span>, <span id="lerp-time-3">t</span>)</code></pre>

<p>
  The vector object is a Javascript array of numbers. A number can be accessed using either brackets [ ] or dot notation with x, y, z. Brackets are required beyond 3-dimensions.
</p>

  <pre class="code"><code>vector.x  <c>// the x value</c><br>vector[<n>0</n>] <c>// also, the x value</c></code></pre>

<p class="explain">
  This vector object is <b>immutable</b>; each method returns a new, transformed vector.
</p>

<h2 id="matrix">
  MATRIX
</h2>

  <div class="equation" id="matrix-1"></div>

<p>
  Matrices are powerful representations of geometric transformations. Inside of one matrix can contain instructions for any number of rotations, translations, reflections, scaling, shearing; and it can tell you things like whether a polygon has been flipped over.
</p>

  <div class="equation" id="matrix-2"></div>

  <div id="canvas-matrix-basis"></div>

<p>
  A 3x4 matrix encodes 3D space, its columns from left to right:
</p>

<ul>
  <li>x-axis basis vector</li>
  <li>y-axis basis vector</li>
  <li>z-axis basis vector</li>
  <li>translation vector</li>
</ul>

  <div class="equation" id="matrix-3"></div>

<p>
  Each matrix us also a one-dimensional Javascript array, each component can be accessed with square brackets using the indices above.
</p>

<p class="explain">
  Matrices are stored <b>column-major</b>, which lines up vector components so each basis vector is contiguous (eg. translation is indices 9, 10, 11)</b>.
</p>

<h3 id="matrix-folding">
  Folding
</h3>

  <div id="canvas-polygon-fold"></div>

<p>
  An example of a matrix in action is a simulation of fold, using a <b>reflection matrix</b>.
</p>

<p class="quote">
  Given a <b>fold line</b>, divide the polygon into two parts (split_convex_polygon) and build a reflection matrix from this fold line. Transform the folding polygon with this matrix.
</p>

<p>
  This library makes it as easy as possible to generate a reflection matrix. Any line type (line, ray, segment) can be turned into a reflection matrix.
</p>

  <pre class="code"><code><f>var</f> segment <key>=</key> ear.<f>segment</f>(<span id="reflection-segment-params">point1, point2</span>)<br><f>var</f> matrix <key>=</key> segment.<f>reflectionMatrix</f>()</code></pre>

  <div id="canvas-matrix-reflection"></div>

  <div class="equation" id="matrix-4"></div>

<p class="explain">
  Unlike vectors, and most objects, matrices are <b>mutable</b>; each method modifies the matrix.
</p>

<pre class="code"><code><f>multiply</f>(<arg>matrix</arg>)
<f>determinant</f>(<arg></arg>)
<f>inverse</f>(<arg></arg>)
<f>translate</f>(<arg>x</arg>, <arg>y</arg>, <arg>z</arg>)
<f>rotate</f>(<arg>radians</arg>, <arg>vector</arg>, <arg>origin</arg>)
<f>scale</f>(<arg>amount</arg>)
<f>reflectZ</f>(<arg>vector</arg>, <arg>origin</arg>)
<f>transform</f>(<arg>vector</arg> or <arg>line</arg>)</code></pre>

<h2 id="line">
  Lines, Rays, Segments
</h2>

  <div id="canvas-intersect-line-ray-segment"></div>

<p>
  <b class="color-yellow">lines</b> extend infinitely in both directions
</p>

<p>
  <b class="color-blue">rays</b> extend infinitely in one direction
</p>

<p>
  line <b class="color-red">segments</b> are bound by two endpoints
</p>

<p>
  Lines and rays are created by specifying a <b>direction vector</b> and an <b>origin</b>. Segments are initialized with two <b>endpoints.</b>
</p>

  <pre class="code"><code>ear.<f>line</f>(<arg>vector</arg>, <arg>origin</arg>)<br>ear.<f>ray</f>(<arg>vector</arg>, <arg>origin</arg>)<br>ear.<f>segment</f>(<arg>point</arg>, <arg>point</arg>)</code></pre>

<p>
  If you leave out the origin argument it is assumed to be (0, 0, 0). Also, it may be easier to create lines and rays with the static method: <b>fromPoints</b>.
</p>

  <div id="canvas-line-ray-segment"></div>

  <pre class="code"><code>ear.line.<f>fromPoints</f>(<span id="lrs-line"></span>)<br>ear.ray.<f>fromPoints</f>(<span id="lrs-ray"></span>)<br>ear.<f>segment</f>(<span id="lrs-segment"></span>)</code></pre>

<p class="explain">
  When a method requires more than one point, points are grouped using arrays.
</p>

<p>
	Lines, rays, and segments all share a common prototype, thus share some properties and methods, like the method <b>nearestPoint</b>. 
</p>

  <div id="canvas-line-nearest-point"></div>

  <pre class="code"><code><f>var</f> point <key>=</key> segment.<f>nearestPoint</f>(<span id="nearest-point-mouse"></span>)</code></pre>

<p>
	All three have an <b>origin</b> and <b>vector</b> property, which is what a line requires for initialization.
</p>

	<pre class="code"><code><f>var</f> segment <key>=</key> ear.<f>segment</f>(<n>1</n>, <n>0</n>, <n>2</n>, <n>-1</n>)<br><f>var</f> line <key>=</key> ear.<f>line</f>(segment)</code></pre>

<p class="quote">
	A segment being converted into a line (infinite length).
</p>

<h2>
  Polygons
</h2>

<p>
  Polygons are created from an ordered set of <b>points</b> which define the boundary. It's possible to create non-convex and self-intersecting polygons. 
</p>

  <pre class="code"><code>ear.<f>polygon</f>(<arg>points</arg>)</code></pre>

<p class="explain">
	Many of the methods in this library are built for convex polygons.
</p>

<h3>
	Convex Polygon
</h3>

  <div id="canvas-polygon-convex-hull"></div>

  <pre class="code"><code>ear.polygon.<f>convexHull</f>(<key>...</key><arg>points</arg>)</code></pre>

<p>
	<b>Convex hull</b> is a static initializer that will also fix any winding issues in an ordered set of points.
</p>

  <div id="canvas-polygon-straight-skeleton"></div>

  <pre class="code"><code>polygon.<f>straightSkeleton</f>()</code></pre>
  <pre class="code"><code>ear.math.<f>straight_skeleton</f>(<arg>points</arg>)</code></pre>

<p>
  The <b>straight skeleton</b> is an operation on a polygon that creates a flat-foldable crease pattern, and when folded, the boundary becomes collinear.
</p>

<h3>
	Rect
</h3>

  <pre class="code"><code>ear.<f>rect</f>(<arg>width</arg>, <arg>height</arg>)<br>ear.<f>rect</f>(<arg>x</arg>, <arg>y</arg>, <arg>width</arg>, <arg>height</arg>)</code></pre>

<h3>
  Circle
</h3>

  <div id="canvas-circle-packing"></div>

  <pre class="code"><code>ear.<f>circle</f>(<arg>radius</arg>)<br>ear.<f>circle</f>(<arg>x</arg>, <arg>y</arg>, <arg>radius</arg>)<br>ear.<f>circle</f>(<arg>origin</arg>, <arg>radius</arg>)</code></pre>

<!-- <p> -->
<!--   A preliminary step in uniaxial-base origami design is circle-packing. -->
<!-- </p> -->

<p class="explain">
  Remember, objects are immutable. If you call a object's method expecting a change, check the return value for a new modified object.
</p>

<h2>
  Intersections
</h2>

<h3>
  Epsilon
</h3>

<p>
	The <b>epsilon</b> is the small number used to decide whether floating point numbers are <em>equal</em>.
</p>

<p>
	This library intends to be useful at <em>any</em> scale; the sketches here demonstrate this. The epsilons on this page have been increased so large to the point of being visible.
</p>

<p class="explain">
  When a method uses an epsilon, the final parameter is the optional epsilon parameter, with a default value of <b>1e-6</b>.
</p>

<h3>
  Collinearity
</h3>

  <div id="canvas-collinear-point"></div>

	<pre class="code"><code>ear.math.<f>point_on_</f>{<str>line/ray/segment</str>}<f>_</f>{<str>inclusive/exclusive</str>}</code></pre>

<p class="quote">
  Is a point collinear to a line (line, ray, segment)?
</p>

<p>
  Endpoints can be treated as <b>inclusive</b> or <b>exclusive</b>, which includes or excludes the area around their endpoints, valid for rays and segments but not lines.
</p>

  <div id="canvas-point-in-poly"></div>

	<pre class="code"><code>ear.math.<f>point_in_convex_poly_inclusive</f>(<arg>point</arg>, <arg>poly</arg>)<br>ear.math.<f>point_in_convex_poly_exclusive</f>(<arg>point</arg>, <arg>poly</arg>)</code></pre>

<p>
  Inclusive and exclusive methods on polygons treat the boundary outset or inset respectively.
</p>

<p class="explain">
	Unlike other geometry-heavy fields, like game development, origami designs are filled with symmetry and collinearity. For example, being able to exclude an edge that lies along a polygon's edge is necessary; handling epsilons with great care is how this library achieves this.
</p>

<h3>
  Overlap, Intersections, and Clipping
</h3>

<ul>
	<li><b>overlap</b> returns true or false</li>
	<li><b>intersect</b> returns points, or undefined if no intersection</li>
	<li><b>clip</b> returns segments, or undefined if no intersection</li>
</ul>

<p class="quote">
	Inclusive and exclusive overlap
</p>

  <div id="canvas-overlap-segment-segment"></div>

<p>
	Overlap methods are just intersection methods that return a boolean instead of a point. In some cases this calculation is faster.
</p>

	<pre class="code"><code>ear.math.<f>overlap_line_ray_inclusive</f>(<arg>vectorA</arg>, <arg>originA</arg>, <arg>vectorB</arg>, <arg>originB</arg>)
ear.math.<f>overlap_ray_segment_exclusive</f>(<arg>vector</arg>, <arg>origin</arg>, <arg>segA1</arg>, <arg>segA2</arg>)
ear.math.<f>overlap_segment_segment_exclusive</f>(<arg>a1</arg>, <arg>a2</arg>, <arg>b1</arg>, <arg>b2</arg>)</code></pre>

<p class="quote">
	Not a complete list
</p>

<p>
	Any combination of line/ray/segment followed by either "inclusive" or "exclusive"; there are 12 methods. Each of these is really just a wrapper around the overlap algorithm, which you can call directly:
</p>

<p class="quote">
	The overlap algorithm
</p>

	<pre class="code"><code>ear.math.<f>overlap_lines</f>(<arg>aVector</arg>, <arg>aOrigin</arg>, <arg>bVector</arg>, <arg>bOrigin</arg>, <arg>compA</arg>, <arg>compB</arg>)</code></pre>

<p>
	To call this method you need to convert segments into vector-origin form, and provide two comparison functions. This gives you the freedom to compare one inclusive against an one exclusive.
</p>

<div class="grid-2">
	<div>
		<pre class="code"><code>ear.math.exclude_l<br>ear.math.exclude_r<br>ear.math.exclude_s</code></pre>
	</div>
	<div>
		<pre class="code"><code>ear.math.include_l<br>ear.math.include_r<br>ear.math.include_s</code></pre>
	</div>
</div>

<p class="quote">
	The inclusive and exclusive comparison functions for lines, rays, or segments.
</p>

	<div id="canvas-overlap-polygon-polygon"></div>

	<pre class="code"><code>polygon1.<f>overlaps</f>(polygon2)</code></pre>

<h3>
Intersect
</h3>

<pre class="code"><code>ear.<f>intersect</f>(<arg>a</arg>, <arg>b</arg>)</code></pre>

<p>
	The <b>intersect</b> function will accept most combinations of pairs of primitives, like lines, circles, polygons; this is the most accessible interface to intersections.
</p>

  <div id="canvas-intersect-polygon-segment"></div>

  <div id="canvas-intersect-circle-segment"></div>

  <pre class="code"><code>polygon.<f>intersect</f>(segment)<br>circle.<f>intersect</f>(segment)</code></pre>

<p>
	The function also exists as a method property on objects. This interface treats intersections as <b>exclusive</b>. For the other options see below.
</p>

	<div id="canvas-intersect-circle-circle"></div>

	<pre class="code"><code>circle1.<f>intersect</f>(circle2)</code></pre>

<p>
	Again, this method is calling other methods under the hood. These are available to you as well.
</p>

<pre class="code"><code><c>// polygon</c>
convex_poly_line_exclusive(<arg>poly</arg>, <arg>vector</arg>, <arg>origin</arg>)
convex_poly_line_inclusive(<arg>poly</arg>, <arg>vector</arg>, <arg>origin</arg>)
convex_poly_ray_exclusive(<arg>poly</arg>, <arg>vector</arg>, <arg>origin</arg>)
convex_poly_ray_inclusive(<arg>poly</arg>, <arg>vector</arg>, <arg>origin</arg>)
convex_poly_segment_exclusive(<arg>poly</arg>, <arg>vector</arg>, <arg>origin</arg>)
convex_poly_segment_inclusive(<arg>poly</arg>, <arg>vector</arg>, <arg>origin</arg>)
<c>// circle</c>
circle_circle(<arg>circleA</arg>, <arg>circleB</arg>)
circle_line(<arg>circle</arg>, <arg>line</arg>)
circle_ray(<arg>circle</arg>, <arg>ray</arg>)
circle_segment(<arg>circle</arg>, <arg>segment</arg>)
<c>// lines</c>
intersect_line_seg_exclude(<arg>vector</arg>, <arg>origin</arg>, <arg>pt0</arg>, <arg>pt1</arg>)
intersect_line_seg_include(<arg>vector</arg>, <arg>origin</arg>, <arg>pt0</arg>, <arg>pt1</arg>)
intersect_ray_seg_exclude(<arg>vector</arg>, <arg>origin</arg>, <arg>pt0</arg>, <arg>pt1</arg>)
intersect_ray_seg_include(<arg>vector</arg>, <arg>origin</arg>, <arg>pt0</arg>, <arg>pt1</arg>)
intersect_seg_seg_exclude(<arg>a0</arg>, <arg>a1</arg>, <arg>b0</arg>, <arg>b1</arg>)
intersect_seg_seg_include(<arg>a0</arg>, <arg>a1</arg>, <arg>b0</arg>, <arg>b1</arg>)</code></pre>

<p>
	Even <em>further</em> under the hood are the actual intersect algorithms. Just like overlap, these require you pass in line/ray/segment comparison functions.
</p>

<pre class="code"><code>ear.math.<f>intersect_lines</f>(<arg>aVector</arg>, <arg>aOrigin</arg>, <arg>bVector</arg>, <arg>bOrigin</arg>, <arg>compA</arg>, <arg>compB</arg>)</code></pre>

<pre class="code"><code>ear.math.<f>intersect_circle_line</f>(<arg>circleRadius</arg>, <arg>circleOrigin</arg>, <arg>vector</arg>, <arg>origin</arg>, <arg>comparisonFunc</arg>)</code></pre>

<p class="quote">
	The line-line and circle-line intersect algorithms
</p>

<p>
  Intersections involving convex polygons results in 0, 1, or 2 points, they return <b>an array of points</b>.
</p>

<p>
	Intersections limited to <em>lines only</em> result in 0 or 1 point, they <b>do not</b> return an array, just a point or undefined.
</p>

<h3>
	Clip
</h3>

  <div id="canvas-clip-polygon-line-ray-segment"></div>

<p>
  Splitting a line by a convex polygon will result in a smaller segment.
</p>

  <pre class="code"><code><span id="clip-line-result"></span>poly.<f>clipLine</f>(<arg>line</arg>)<br>poly.<f>clipRay</f>(<arg>ray</arg>)<br>poly.<f>clipSegment</f>(<arg>segment</arg>)</code></pre>

<h2 id="angles-and-winding-order">
  Angles and Winding-order
</h2>

	<div id="canvas-radial-between"></div>

  <pre class="code"><code>ear.math.<f>is_counter_clockwise_between</f>(<arg>circle</arg>, <arg>angle1</arg>, <arg>angle2</arg>)</code></pre>

<p>
  The space between two vectors creates two interior angles. It's important to distinguish between vectors <b>a</b> and <b>b</b> the <b>clockwise</b> or the <b>counter-clockwise</b> interior angle.
</p>

<p class="quote">
	Get the interior angle between two radians/vectors.
</p>

  <pre class="code"><code>ear.math.<f>clockwise_angle_radians</f>(<arg>angle1</arg>, <arg>angle2</arg>)
ear.math.<f>counter_clockwise_angle_radians</f>(<arg>angle1</arg>, <arg>angle2</arg>)
ear.math.<f>clockwise_angle2</f>(<arg>vector1</arg>, <arg>vector2</arg>)
ear.math.<f>counter_clockwise_angle2</f>(<arg>vector1</arg>, <arg>vector2</arg>)</code></pre>

<p>
	When operating on angles, these methods seamlessly wrap around from 2π to 0 and include negative radians as similar to their positive counterparts.
</p>

<h3 id="sorting">
	Sorting
</h3>

	<div id="canvas-radial-order"></div>

<!-- <p class="quote"> -->
<!-- 	shortest to longest -->
<!-- </p> -->

	<pre class="code"><code><span id="radial-order-result"></span></code></pre>

	<pre class="code"><code>ear.math.<f>counter_clockwise_vector_order</f>(<key>...</key><arg>vectors</arg>)<br>ear.math.<f>counter_clockwise_radians_order</f>(<key>...</key><arg>angles_in_radians</arg>)<br></code></pre>

<p>
	Sort an array of vectors or angles, but return the result as an array of indices instead of modifying the array.
</p>

<p class="explain">
	The first argument serves as the "origin" angle that other vectors are sorted around". Index 0 will always be 0.
</p>

<p>
	Sorting is required for such simple things as measuring the interior angles between <em>consecutive</em> vectors.
</p>

	<div id="canvas-radial-sectors"></div>

<p>
	The red line is the first in the vector array; you can tell the algorithm sorts around it as the sector colors shift more when it is moved.
</p>

<h3>
	Bisect
</h3>

  <div id="canvas-radial-bisect"></div>

	<pre class="code"><code>ear.math.<f>clockwise_bisect2</f>(<arg>vector1</arg>, <arg>vector2</arg>)
ear.math.<f>counter_clockwise_bisect2</f>(<arg>vector1</arg>, <arg>vector2</arg>)</code></pre>

<p>
	A bisection could refer to the smaller or the larger angle; these methods return one solution by clarifying clockwise or counter-clockwise.
</p>

<p>
	Bisecting two lines is effectively origami axiom #3, and results in two solutions unless the lines are parallel.
</p>

	<pre class="code"><code>ear.math.<f>bisect_lines2</f>(<arg>vectorA</arg>, <arg>originA</arg>, <arg>vectorB</arg>, <arg>originB</arg>)</code></pre>

	<div id="canvas-radial-bisect-lines"></div>

	<pre class="code"><code><span id="radial-bisect-lines-result"></span></code></pre>

<p>
	The parallel case maintains the index position of each line. The lines are sorted based on if the parameter lines are running in the same direction or not (dot product &gt; 0).
</p>

<p>
	For trisections and beyond, use the general <b>subsect</b> methods.
</p>

	<pre class="code"><code>ear.math.<f>counter_clockwise_subsect2</f>(<arg>divisions</arg>, <arg>vectorA</arg>, <arg>vectorB</arg>)
ear.math.<f>counter_clockwise_subsect_radians</f>(<arg>divisions</arg>, <arg>angleA</arg>, <arg>angleB</arg>)</code></pre>

<!-- <h2> -->
<!--   Methods -->
<!-- </h2> -->

<!-- <p> -->
<!--   Objects like vector do some overhead to make sure arguments are in the correct form. <b>ear.math</b> gives direct access to these methods; these have the fastest execution time, just make sure parameters are in the correct form. -->
<!-- </p> -->

<!--   <pre class="code"><code>ear.math.<f>magnitude</f>(<arg>vector</arg>) -->
<!-- ear.math.<f>normalize</f>(<arg>vector</arg>) -->
<!-- ear.math.<f>scale</f>(<arg>vector</arg>, <arg>scale</arg>) -->
<!-- ear.math.<f>add</f>(<arg>vec1</arg>, <arg>vec2</arg>) -->
<!-- ear.math.<f>subtract</f>(<arg>vec1</arg>, <arg>vec2</arg>) -->
<!-- ear.math.<f>dot</f>(<arg>vec1</arg>, <arg>vec2</arg>) -->
<!-- ear.math.<f>midpoint</f>(<arg>vec1</arg>, <arg>vec2</arg>) -->
<!-- ear.math.<f>lerp</f>(<arg>vec1</arg>, <arg>vec2</arg>, <arg>t</arg>) -->
<!-- ear.math.<f>cross2</f>(<arg>vec1</arg>, <arg>vec2</arg>) -->
<!-- ear.math.<f>cross3</f>(<arg>vec1</arg>, <arg>vec2</arg>) -->
<!-- ear.math.<f>distance</f>(<arg>vec1</arg>, <arg>vec2</arg>)</code></pre> -->

<!-- <p> -->
<!--   This is an abbreviated list. Check out more in the Appendix. -->
<!-- </p> -->
<script type="text/javascript">
const options = {
	callback: {
		"vector": (e) => {
			if (e === undefined) { return; }
  		const vec = `<n>${e.vector.x.toFixed(2)}</n>, <n>${e.vector.y.toFixed(2)}</n>`;
  		const norm = `[${e.normalized.x.toFixed(2)}, ${e.normalized.y.toFixed(2)}]`;
  		document.querySelector("#vec-sketch-vector").innerHTML = vec;
  		document.querySelector("#vec-sketch-vector-normalized").innerHTML = norm;
		},
		"vector-lerp": (e) => {
  		if (e == undefined || e.t === undefined) { return; }
  		document.querySelector("#lerp-time-1").innerHTML = e.t.toFixed(2);
  		document.querySelector("#lerp-time-2").innerHTML = e.t.toFixed(2);
  		document.querySelector("#lerp-time-3").innerHTML = e.t.toFixed(2);
		},
		"line-ray-segment": (e) => {
  		if (e == undefined) { return; }
  		const ids = ["#lrs-line", "#lrs-ray", "#lrs-segment"];
  		Array.from(Array(3))
    		.map((_, i) => [i*2, i*2 + 1])
    		.map(el => el.map(i => e.points[i]))
    		.forEach((seg, i) => {
					document.querySelector(ids[i]).innerHTML = `[<n>${seg[0].x.toFixed(1)}</n>, <n>${seg[0].y.toFixed(1)}</n>], [<n>${seg[1].x.toFixed(1)}</n>, <n>${seg[1].y.toFixed(1)}</n>]`;
			});
		},
		"matrix-reflection": (event) => {
  		if (event.matrix == null) { return; }
  // katex.render("\\begin{bmatrix} "+event.matrix[0].toFixed(1)+" & "+event.matrix[2].toFixed(1)+" & "+event.matrix[4].toFixed(1) +" \\\\ "+event.matrix[1].toFixed(1)+" & "+event.matrix[3].toFixed(1)+" & "+event.matrix[5].toFixed(1) +" \\end{bmatrix}", document.querySelector("#matrix-4"));
  		document.querySelector("#reflection-segment-params").innerHTML = "<n>"
    		+ parseInt(event.segment[0].x) + "</n>, <n>"
    		+ parseInt(event.segment[0].y) + "</n>, <n>"
    		+ parseInt(event.segment[1].x) + "</n>, <n>"
    		+ parseInt(event.segment[1].y) + "</n>";
		},
		"radial-order": (event) => {
			if (event.order) {
				document.querySelector("#radial-order-result")
					.innerHTML = "[" + event.order
						.map(n => "<n>" + n + "</n>")
						.join(", ") + "]";
			}
		},
		"radial-bisect-lines": (event) => {
			if (event && event.bisect) {

				const printLine = line => "{ vector: [" + 
					"<n>" + line.vector[0].toFixed(1) + "</n>, " +
					"<n>" + line.vector[1].toFixed(1) + "</n>], origin: [" +
					"<n>" + line.origin[0].toFixed(1) + "</n>, " +
					"<n>" + line.origin[1].toFixed(1) + "</n>] }"

				document.querySelector("#radial-bisect-lines-result")
					.innerHTML = "[<br>  " + (event.bisect[0] === undefined
						? "<n>undefined</n>" : printLine(event.bisect[0])) + 
						"<br>  " +
						(event.bisect[1] === undefined
						? "<n>undefined</n>" : printLine(event.bisect[1])) +
						"<br>]";
			}
		},
	}
};
</script>

<script type="text/javascript" src="./js/loadExamples.js"></script>

<script type="text/javascript">
loadExamples([
  "vector",
  "vector-lerp",
  "collinear-point",
  "junction-bisect",
  "line-nearest-point",
  "line-ray-segment",
  "matrix-reflection",
  "polygon-fold",
  "polygon-straight-skeleton",
	"polygon-convex-hull",
  // "circle-packing",
  "point-in-poly",
	"overlap-segment-segment",
	"overlap-polygon-polygon",
  "intersect-line-ray-segment",
	"intersect-polygon-segment",
  "intersect-circle-segment",
	"intersect-circle-circle",
  "clip-polygon-line-ray-segment",
	"radial-between",
	"radial-order",
	"radial-sectors",
	"radial-bisect",
	"radial-bisect-lines",
], options);
</script>

<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
	integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X"
	crossorigin="anonymous">

<script 
	src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
	integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
	crossorigin="anonymous"
></script>

<script type="text/javascript">
katex.render("\\begin{bmatrix} \\hat{\\text{\\i}}_x & \\hat{\\text{\\j}}_x & \\hat{k}_x & t_x \\\\ \\hat{\\text{\\i}}_y & \\hat{\\text{\\j}}_y & \\hat{k}_y & t_y \\\\ \\hat{\\text{\\i}}_z & \\hat{\\text{\\j}}_z & \\hat{k}_z & t_z \\end{bmatrix}", document.querySelector("#matrix-1"));

katex.render("\\begin{bmatrix} \\hat{\\text{\\i}}_x \\\\ \\hat{\\text{\\i}}_y \\\\ \\hat{\\text{\\i}}_z \\end{bmatrix} \\begin{bmatrix} \\hat{\\text{\\j}}_x \\\\ \\hat{\\text{\\j}}_y \\\\ \\hat{\\text{\\j}}_z \\end{bmatrix} \\begin{bmatrix} \\hat{k}_x \\\\ \\hat{k}_y \\\\ \\hat{k}_z \\end{bmatrix} \\begin{bmatrix} t_x \\\\ t_y \\\\ t_z \\end{bmatrix}", document.querySelector("#matrix-2"));

katex.render("\\begin{bmatrix} 0 & 3 & 6 & 9 \\\\ 1 & 4 & 7 & 10 \\\\ 2 & 5 & 8 & 11 \\end{bmatrix}", document.querySelector("#matrix-3"));
</script>

<!-- START OF FOOTER -->
<!-- START OF FOOTER -->
<!-- START OF FOOTER -->
  </div>
</body>
</html>
<!-- END OF FOOTER -->
<!-- END OF FOOTER -->
<!-- END OF FOOTER -->
